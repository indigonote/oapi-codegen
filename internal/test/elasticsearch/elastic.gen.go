// Package elasticsearch provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/indigonote/oapi-codegen DO NOT EDIT.
package elasticsearch

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Consulter defines model for consulter.
type Consulter struct {

	// FHIR Encounter
	Consultation *FhirEncounter `json:"consultation,omitempty"`

	// consulter article count
	ConsultationArticleCount *float32 `json:"consultationArticleCount,omitempty"`

	// FHIR Patient
	Consulter *FhirPatient `json:"consulter,omitempty"`
}

// ConsulterCreateRequest defines model for consulter-create-request.
type ConsulterCreateRequest struct {
	Consulters *[]CreateConsulter `json:"consulters,omitempty"`
}

// ConsulterCreateResponse defines model for consulter-create-response.
type ConsulterCreateResponse ConsulterPerPage

// ConsulterPerPage defines model for consulter-per-page.
type ConsulterPerPage struct {

	// consulter list
	Consulters *[]Consulter `json:"consulters,omitempty"`
}

// CreateConsulter defines model for create-consulter.
type CreateConsulter struct {
	Codesystem *FhirCodeSystem `json:"codesystem,omitempty"`

	// FHIR Encounter
	Consultation *FhirEncounter `json:"consultation,omitempty"`

	// FHIR Patient
	Consulter *FhirPatient `json:"consulter,omitempty"`
}

// FhirAddress defines model for fhir-address.
type FhirAddress struct {
	Country    *string `json:"country" validate:"omitempty,max=1048576,fhirString"`
	PostalCode *string `json:"postalCode" validate:"omitempty,max=1048576,fhirString"`
	Text       *string `json:"text" validate:"omitempty,max=1048576,fhirString"`
}

// FhirAttachment defines model for fhir-attachment.
type FhirAttachment struct {

	// Mime type of the content, with charset etc.
	ContentType *string `json:"contentType" validate:"omitempty,fhirCode"`

	// The date that the attachment was first created.
	Creation *string `json:"creation" validate:"omitempty,fhirDateTime"`

	// The actual data of the attachment - a sequence of bytes, base64 encoded.
	Data *string `json:"data" validate:"omitempty,fhirBase64Binary"`

	// The calculated hash of the data using SHA-1. Represented using base64.
	Hash *string `json:"hash" validate:"omitempty,fhirBase64Binary"`

	//
	// The human language of the content. The value can be any valid value according to BCP 47.
	Language *string `json:"language" validate:"omitempty,fhirCode"`

	// The number of bytes of data that make up this attachment (before base64 encoding, if that is done).Number of bytes of content (if url provided)
	Size *int `json:"size,omitempty" validate:"omitempty,fhirUnsignedInt"`

	// A label or set of text to display in place of the data.
	Title *string `json:"title" validate:"omitempty,max=1048576,fhirString"`

	// Uri where the data can be found
	Url *string `json:"url"`
}

// FhirCodeSystem defines model for fhir-code-system.
type FhirCodeSystem struct {
	Concept *[]FhirConcept `json:"concept,omitempty"`
	Content string         `json:"content" validate:"oneof=complete "`
	Id      *string        `json:"id,omitempty" validate:"omitempty,fhirID"`
	Name    *string        `json:"name,omitempty" validate:"omitempty,max=1048576,fhirString"`
	Status  string         `json:"status" validate:"oneof=active "`
	Title   *string        `json:"title,omitempty" validate:"omitempty,max=1048576,fhirString"`
}

// FhirCodeableConcept defines model for fhir-codeable-concept.
type FhirCodeableConcept struct {
	Coding *[]FhirCoding `json:"coding,omitempty"`
}

// FhirCoding defines model for fhir-coding.
type FhirCoding struct {
	Code   *string `json:"code" validate:"omitempty,fhirCode"`
	System *string `json:"system" validate:"omitempty,fhirUri"`
}

// FhirConcept defines model for fhir-concept.
type FhirConcept struct {
	Code    string         `json:"code" validate:"fhirCode"`
	Concept *[]FhirConcept `json:"concept,omitempty"`
	Display *string        `json:"display,omitempty" validate:"omitempty,max=1048576,fhirString"`
}

// FhirContactPoint defines model for fhir-contact-point.
type FhirContactPoint struct {
	System *string `json:"system" validate:"omitempty,oneof=phone email "`
	Value  *string `json:"value" validate:"omitempty,max=1048576,fhirString"`
}

// FhirEncounter defines model for fhir-encounter.
type FhirEncounter struct {

	// FHIR Coding
	Class FhirCoding `json:"class"`
	Id    *string    `json:"id" validate:"omitempty,fhirID"`

	// FHIR Meta
	Meta        *FhirMeta `json:"meta"`
	Participant *[]struct {

		// FHIR Reference
		Individual *FhirReference         `json:"individual"`
		Type       *[]FhirCodeableConcept `json:"type,omitempty"`
	} `json:"participant,omitempty"`

	// planned | arrived | triaged | in-progress | onleave | finished | cancelled | entered-in-error | unknown
	Status string `json:"status" validate:"oneof=planned arrived triaged in-progress onleave finished cancelled entered-in-error unknown "`
}

// FhirExtension defines model for fhir-extension.
type FhirExtension struct {
	Url             string `json:"url" validate:"fhirUri"`
	ValueAttachment *struct {
		// Embedded struct due to allOf(#/components/schemas/fhir-attachment)
		FhirAttachment
	} `json:"valueAttachment" validate:"omitempty,fhirValueX"`
	ValueCode      *string `json:"valueCode" validate:"omitempty,fhirCode,fhirValueX"`
	ValueInstant   *string `json:"valueInstant" validate:"omitempty,fhirInstant,fhirValueX"`
	ValueReference *struct {
		// Embedded struct due to allOf(#/components/schemas/fhir-reference)
		FhirReference
	} `json:"valueReference" validate:"omitempty,fhirValueX"`
	ValueString *string `json:"valueString" validate:"omitempty,fhirString,fhirValueX,max=1048576"`
}

// FhirHumanName defines model for fhir-human-name.
type FhirHumanName struct {
	Extension *[]FhirExtension `json:"extension,omitempty"`
	Text      *string          `json:"text" validate:"omitempty,max=1048576,fhirString"`
	Use       *string          `json:"use" validate:"omitempty,oneof=usual official "`
}

// FhirIdentifier defines model for fhir-identifier.
type FhirIdentifier struct {
	System *string `json:"system" validate:"omitempty,fhirUri"`
	Use    *string `json:"use" validate:"omitempty,oneof=usual official "`
	Value  *string `json:"value" validate:"omitempty,fhirString,max=1048576"`
}

// FhirMeta defines model for fhir-meta.
type FhirMeta struct {
	Extension   *[]FhirExtension `json:"extension,omitempty"`
	LastUpdated *string          `json:"lastUpdated" validate:"omitempty,fhirInstant"`
	Security    *[]FhirCoding    `json:"security,omitempty"`
	Tag         *[]FhirCoding    `json:"tag,omitempty"`
	VersionId   *string          `json:"versionId,omitempty" validate:"omitempty,fhirID"`
}

// FhirPatient defines model for fhir-patient.
type FhirPatient struct {

	// active status of patient
	Active *bool `json:"active"`

	// list address of patient
	Address *[]FhirAddress `json:"address,omitempty"`

	// birth date of patient
	BirthDate *string `json:"birthDate" validate:"omitempty,fhirDate"`

	// Additional contents of patient
	Extension *[]FhirExtension `json:"extension,omitempty"`

	// gender of patient: male | female | other | unknown
	Gender *string `json:"gender" validate:"omitempty,oneof=male female other unknown "`

	// list general practitioner
	GeneralPractitioner *[]FhirReference `json:"generalPractitioner,omitempty"`

	// id of patient
	Id *string `json:"id" validate:"omitempty,fhirID"`

	// list identifier of patient
	Identifier *[]FhirIdentifier `json:"identifier,omitempty"`

	// Link to another patient resource that concerns the same actual person
	Link *[]struct {

		// FHIR Reference
		Other *FhirReference `json:"other"`

		// type reference: replaced-by | replaces
		Type string `json:"type" validate:"oneof=replaced-by replaces "`
	} `json:"link,omitempty"`

	// FHIR Meta
	Meta *FhirMeta `json:"meta"`

	// name of patient
	Name *[]FhirHumanName `json:"name,omitempty"`

	// telecom of patient
	Telecom *[]FhirContactPoint `json:"telecom,omitempty"`
}

// FhirReference defines model for fhir-reference.
type FhirReference struct {
	Extension *[]FhirExtension `json:"extension,omitempty"`
	Reference *string          `json:"reference" validate:"omitempty,fhirString,max=1048576"`
	Type      *string          `json:"type" validate:"omitempty,fhirUri"`
}

// PostConsultersJSONBody defines parameters for PostConsulters.
type PostConsultersJSONBody ConsulterCreateRequest

// PostConsultersRequestBody defines body for PostConsulters for application/json ContentType.
type PostConsultersJSONRequestBody PostConsultersJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostConsulters request  with any body
	PostConsultersWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	PostConsulters(ctx context.Context, body PostConsultersJSONRequestBody) (*http.Response, error)
}

func (c *Client) PostConsultersWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPostConsultersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostConsulters(ctx context.Context, body PostConsultersJSONRequestBody) (*http.Response, error) {
	req, err := NewPostConsultersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewPostConsultersRequest calls the generic PostConsulters builder with application/json body
func NewPostConsultersRequest(server string, body PostConsultersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostConsultersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostConsultersRequestWithBody generates requests for PostConsulters with any type of body
func NewPostConsultersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/consulters")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostConsulters request  with any body
	PostConsultersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostConsultersResponse, error)

	PostConsultersWithResponse(ctx context.Context, body PostConsultersJSONRequestBody) (*PostConsultersResponse, error)
}

type PostConsultersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConsulterCreateResponse
}

// Status returns HTTPResponse.Status
func (r PostConsultersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostConsultersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostConsultersWithBodyWithResponse request with arbitrary body returning *PostConsultersResponse
func (c *ClientWithResponses) PostConsultersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*PostConsultersResponse, error) {
	rsp, err := c.PostConsultersWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostConsultersResponse(rsp)
}

func (c *ClientWithResponses) PostConsultersWithResponse(ctx context.Context, body PostConsultersJSONRequestBody) (*PostConsultersResponse, error) {
	rsp, err := c.PostConsulters(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParsePostConsultersResponse(rsp)
}

// ParsePostConsultersResponse parses an HTTP response from a PostConsultersWithResponse call
func ParsePostConsultersResponse(rsp *http.Response) (*PostConsultersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostConsultersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConsulterCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Post Consulters
	// (POST /consulters)
	PostConsulters(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostConsulters converts echo context to params.
func (w *ServerInterfaceWrapper) PostConsulters(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostConsulters(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/consulters", wrapper.PostConsulters)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"VqHry/X/AwAA///f7tCcrCsAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
